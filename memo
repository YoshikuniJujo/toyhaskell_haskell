2011.08.16 Tue.

toyhaskell を作る。
まずは、interractive な環境における電卓的プログラムを作成するか。
evaluate によってコードから値を導いてみるか。

2011.08.17 Wed.

だいぶいい感じだ。
次は import を実そうしよう。
それととりあえず型せん言は無視するようにしようかな。

それと、そろそろパターンマッチ構文を使えるようにしよう。

その前に型クラスについて考える必要がある。
まずは、[ a ] 型を扱えるようにして、(++) を定義しよう。
その前に、String 型を無くして、[ Char ] として実そうしてみようかな。

2011.08.18 Thu.

次は、String を [ Char ] として定義する。
その前に型について考えたほうが良いかもしれない。

だいぶコードがぐちゃぐちゃになってきたのでコード整理をする。
しかし、そのなかで、Env を [ ( String, Value ) ] ではなく、
[ ( Pattern, Value ) ] として持つべきかもしれないという問題が出てくる。

type Env = [ ( [ String ], Pattern, Value ) ] とするべきかもしれない。
これだけ複雑だと、data Env = Env [ ( [ String ], Pattern, Value ) ]
としたほうが良いだろう。
その前段階として、data Env = Env [ ( String, Value ) ] として、
明示的な interface を定義するべきだろう。

eval の Apply まで refactoring した。
次は eval の Letin から refactoring すること。

Eval の patMatch1 を Value の patMatch1 を使って定義するようにしよう。

とりあえず今回の refactoring では、あと Parser と Value を残すのみだ。
しかし、Parser はけっこう手強そうだ。

Parser を parse 部分と preprocess 部分とで分けようかな。

すると refactoring の残りは Parser, Preprocessor, Value となる。

さらに、Parser と Lexer を分けようかな。

演算子についても問題なく扱えるようになった。
この時点で refactoring するのに残っているのが、Parser, BuildExpression, Lexer, Preprocessor,
Value となる。
とりあえず Parser の refactoring から始めよう。

Parser
BuildExpression
Lexer
Preprocessor
Value

2011.08.22 Mon.

次は Parser の refactoring だ。
現在残っているのが、 BuildExpression, Preprocessor, Lexer,
Value の refactoring だ。

2011.08.23 Tue.

Env を capsule 化したいが、getValue には eval が必要だ。
となると Env を含む module は Eval を import する必要があることとなる。
むしろ、getValue に eval を引数として渡すような形がいいのかもしれない。

module Main where を parse するようにする。

getOpTable は将来的には Parser の一部とするので、
今のところ Parser に置くのが適切ではないが、そこに置いておくことにする。

残りは、BuildExpression, Preprocessor, Lexer, Types の refactoring

近いうちに lex を haskell 98 report に則って書き直そう。
2010 のほうがいいのかもしれないけれど 98 のほうは日本語訳がある。

2010 にも日本語訳があった。
