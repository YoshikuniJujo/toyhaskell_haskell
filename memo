2011.08.16 Tue.

toyhaskell を作る。
まずは、interractive な環境における電卓的プログラムを作成するか。
evaluate によってコードから値を導いてみるか。

2011.08.17 Wed.

だいぶいい感じだ。
次は import を実そうしよう。
それととりあえず型せん言は無視するようにしようかな。

それと、そろそろパターンマッチ構文を使えるようにしよう。

その前に型クラスについて考える必要がある。
まずは、[ a ] 型を扱えるようにして、(++) を定義しよう。
その前に、String 型を無くして、[ Char ] として実そうしてみようかな。

2011.08.18 Thu.

次は、String を [ Char ] として定義する。
その前に型について考えたほうが良いかもしれない。

だいぶコードがぐちゃぐちゃになってきたのでコード整理をする。
しかし、そのなかで、Env を [ ( String, Value ) ] ではなく、
[ ( Pattern, Value ) ] として持つべきかもしれないという問題が出てくる。

type Env = [ ( [ String ], Pattern, Value ) ] とするべきかもしれない。
これだけ複雑だと、data Env = Env [ ( [ String ], Pattern, Value ) ]
としたほうが良いだろう。
その前段階として、data Env = Env [ ( String, Value ) ] として、
明示的な interface を定義するべきだろう。

eval の Apply まで refactoring した。
次は eval の Letin から refactoring すること。

Eval の patMatch1 を Value の patMatch1 を使って定義するようにしよう。

とりあえず今回の refactoring では、あと Parser と Value を残すのみだ。
しかし、Parser はけっこう手強そうだ。

Parser を parse 部分と preprocess 部分とで分けようかな。

すると refactoring の残りは Parser, Preprocessor, Value となる。

さらに、Parser と Lexer を分けようかな。

演算子についても問題なく扱えるようになった。
この時点で refactoring するのに残っているのが、Parser, BuildExpression, Lexer, Preprocessor,
Value となる。
とりあえず Parser の refactoring から始めよう。

Parser
BuildExpression
Lexer
Preprocessor
Value

2011.08.22 Mon.

次は Parser の refactoring だ。
現在残っているのが、 BuildExpression, Preprocessor, Lexer,
Value の refactoring だ。

2011.08.23 Tue.

Env を capsule 化したいが、getValue には eval が必要だ。
となると Env を含む module は Eval を import する必要があることとなる。
むしろ、getValue に eval を引数として渡すような形がいいのかもしれない。

module Main where を parse するようにする。

getOpTable は将来的には Parser の一部とするので、
今のところ Parser に置くのが適切ではないが、そこに置いておくことにする。

残りは、BuildExpression, Preprocessor, Lexer, Types の refactoring

近いうちに lex を haskell 98 report に則って書き直そう。
2010 のほうがいいのかもしれないけれど 98 のほうは日本語訳がある。

2010 にも日本語訳があった。

Types のなかに無理矢理入れている Env に関する関数を別モジュールに
しようかな。

今の構造だと Env のカプセル化が上手くいかない。
もうすこし考える必要がある。

2011.08.25 Thu.

次にするべきこと

* module ... where をつける
* case ... of ... 以外にもきちんとした layout rule を適応する
* 型をつける

layout rule が思った以上に難物だった。
問題は、パースエラーが生じる箇所で、そこに '}' が存在しても良い場所に
おいて、'}' を挿入するという rule だ。
これは、独立したテスト用の program を作成する必要がある。
let a = 3 in a をパースする program を書いてみよう。

ひとつの案があったのだが、それは prep の方に '}' を挿入したという
通知が出来ないためうまくいかなかった。

字句解折、構文解折における実装の全面的な見直しが必要なようだ。
Token が必要になるたびに preprocessor を動かすという構造にする必要がある。
Parsec を使用したままでできるだろうか。
Happy における モナド字句解折器という考え方を使えば良い。
Parsec よりも Happy を使うべきだったかもしれない。

ここで、僕は選択に迫られる。
Happy を学ぶか、あるいは Parser Generator を自分で作るか、だ。
後者のほうが実は楽なのだが、
車輪の再発明よりも新しい概念を学ぶほうが良い気がする。
前に一度 Parser Generator は作ったことあるし。
すこし、Happy を学んでみることにしようかな。

infix 宣言によって parse の仕方を変える必要は無いのかもしれない。
operator は、operator として parse しておいて、
eval の段階で結合性を考えれば良いのではないだろうか。
つまり、Expr Val [ ( Op, Val ) ] という形で、Parse しておいて、
Eval の段階でその結合性を決めるというやりかたはどうだろうか。
あるいは、Expr [ Val ] としておいて Op も Val に
含ませておくほうが良いかもしれない。
そして結合性 9 のものから順に組み立てて行けば良い。

HsParser.y では、hsInfixApp val op val の形にしている様だ。
結合性については eval の段階でどうにかしているのだろう。

式は、とりあえず Expr [ val, op, val, op, val, op, val ] の形で持っておいて、
infix 宣言を使って最度パースするという形にするしかないようにも思う。

2011.08.26 Fri.

haskell-src-exts の parser を見ても、
やはり式については同じ方法を採っているようだ。
